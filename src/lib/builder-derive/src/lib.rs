use heck::ToUpperCamelCase;
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote};
use syn::{Data, DeriveInput, Fields, parse_macro_input};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;
    let builder_name = format_ident!("{}Builder", name);

    let generics = &ast.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let named_fields = match &ast.data {
        Data::Struct(s) => {
            if let Fields::Named(n) = &s.fields {
                n.named.iter().collect::<Vec<_>>()
            } else {
                panic!("Builder support only named fields in structs");
            }
        }
        _ => panic!("Builder can be cast only on structs"),
    };

    let idents: Vec<_> = named_fields
        .iter()
        .map(|f| f.ident.as_ref().expect("expected field to have an ident"))
        .collect();
    let types: Vec<_> = named_fields.iter().map(|f| &f.ty).collect();
    let errs: Vec<_> = idents
        .iter()
        .map(|ident| format_ident!("Missing{}", ident.to_string().to_upper_camel_case()))
        .collect();

    let expanded: TokenStream2 = quote! {
        #[derive(Default)]
        pub struct #builder_name #generics #where_clause {
            #(pub #idents: Option<#types>,)*
        }

        impl #impl_generics #builder_name #ty_generics #where_clause {
        /// Creates a new instance of the builder.
        ///
        /// # Examples
        ///
        /// ```rust
        /// use crate::builder_derive::Builder;
        /// #[derive(Builder)]
        /// struct MyStruct {
        ///    field1: String,
        ///   field2: i32,
        /// }
        /// let my_struct = MyStructBuilder::new();
        /// ```
        ///
        /// This method is automatically generated by the `Builder` derive macro.

            pub fn new() -> Self { Default::default() }

            /// Sets the value for the field.
            /// # Examples
            /// ```rust
            /// use crate::builder_derive::Builder;
            /// #[derive(Builder)]
            /// struct MyStruct {
            ///    field1: String,
            ///    field2: i32,
            /// }
            /// let my_struct = MyStructBuilder::new()
            /// .field1("Some string value".to_string())
            /// .field2(1);
            ///```
            /// This method is automatically generated by the `Builder` derive macro.
            #(
                pub fn #idents(mut self, value: #types) -> Self {
                    self.#idents = Some(value);
                    self
                }
            )*

            /// Builds the struct, returning an error if any required fields are missing.
            /// # Examples
            /// ```rust
            /// use crate::builder_derive::Builder;
            /// #[derive(Builder)]
            /// struct MyStruct {
            ///   field1: String,
            ///  field2: i32,
            /// }
            /// let my_struct = MyStructBuilder::new()
            ///    .field1("Some string value".to_string())
            ///   .field2(1)
            ///   .build()
            ///   .expect("Failed to build MyStruct");
            /// ```
            /// This method is automatically generated by the `Builder` derive macro.

            pub fn build(self) -> Result<#name #ty_generics> {
                Ok(#name {
                    #(
                        #idents: self.#idents.ok_or(BuildError::#errs)?,
                    )*
                })
            }
        }
    };

    expanded.into()
}
